import os
import re
import shutil
import sys
from fileinput import FileInput

from .SortedTable import SortedTable


class MessageParser:
    """
    Used to tidy and parse the message logs created by Cadmium's logging system.

    Attributes
    ----------
    input_log_file: str
        The state log file to tidy and parse.
    inplace: bool
        Determine whether to modify the original file or create a new one.
    """

    def __init__(self, input_log_file, inplace=False):
        """
        Constructs the necessary attributes for the MessageParser object.

        :param input_log_file: The message log file to tidy and parse.
        :param inplace: Whether the file should be edited inplace
        """
        self.input_log_file = os.path.abspath(input_log_file)
        self.inplace = inplace

    def tidy(self):
        """
        Tidies the input file for easier parsing.

        :return: None
        """
        tidy_file = self.__get_adjusted_path()
        if not self.inplace:
            shutil.copyfile(self.input_log_file, tidy_file)

        for line in FileInput(tidy_file, inplace=True):
            match = re.match(r"[0-9]{2}:[0-9]{2}:[0-9]{2}:[0-9]{3}", line)
            if match:
                print(match.group(0))
                continue

            # Matches any line that does not start with a "[" and removes it.
            match = re.match(r"^(?!\[).", line)
            if match:
                continue

            # Matches any line not containing "] generated by model" and removes it.
            match = re.match(r"^(?:(?!] generated by model).)*$", line)
            if match:
                continue

            # Matches any line containing "[] generated by model" and removes it.
            match = re.match(r"^\[] generated by model", line)
            if match:
                continue

            # Matches any line with all empty outputs and removes it.
            match_list = re.findall(r"{(.*?)}", line)
            if match_list:
                is_empty = True
                for val in match_list:
                    if val != "":
                        is_empty = False
                if is_empty:
                    continue
            sys.stdout.write(line)

    def parse(self):
        """
        Parse the tidied input file into a 2D array. The 2d array consists of a
        header with the Time and state names and the rest consists of the data.

        :return: 2D array where the first row is the headers and the rest is the states and time.
        """
        sorted_table = SortedTable()
        sorted_table.create_header(None, ["Time", "Output Model", "Output Port", "Value"])
        sorted_table.add_header_to_table()
        sorted_table.next_row()

        tidy_file = self.__get_adjusted_path()
        time = ""
        for line in FileInput(tidy_file):
            # Matches the time, adds it to the table, if different from last time.
            match = re.match(r"[0-9]{2}:[0-9]{2}:[0-9]{2}:[0-9]{3}", line)
            if match:
                if match.group(0) != time:
                    time = match.group(0)
                    sorted_table["Time"] = time

            match = re.search("generated by model (.*)", line)
            match_list = re.findall(r"(?<=(?:defs::)|(?:...>::))(.*?): {(.*?)}", line)
            for val in match_list:
                if val[1] != "":
                    sorted_table["Output Port"] = val[0]
                    sorted_table["Value"] = val[1]
                    sorted_table["Output Model"] = match.group(1)
                    sorted_table.next_row()
        return sorted_table

    def is_accessible(self):
        """
        Verifies that the input file exists and is accessible.

        :return: True if the path and file are accessible false otherwise.
        """

        if self.inplace:
            return os.access(self.input_log_file, os.W_OK)
        else:
            path = os.path.dirname(self.input_log_file)
            return os.access(self.input_log_file, os.R_OK) and os.access(path, os.W_OK)

    def __get_adjusted_path(self):
        """
        Used to get the file path depending on if it is an inplace procedure or not.

        :return: Original path if inplace is false else append .tmp to the path.
        """
        file = self.input_log_file
        if not self.inplace:
            file = file + ".tmp"
        return file
